"""
Page de visualisation du r√©seau FTL
Interface Streamlit pour afficher graphiquement les connexions FTL entre syst√®mes
"""

import streamlit as st
import json
import os
from streamlit_agraph import agraph, Node, Edge, Config
from typing import Dict, List, Tuple

def load_ftl_data():
    """Charge les donn√©es du r√©seau FTL depuis le fichier JSON"""
    ftl_file = os.path.join(os.path.dirname(__file__), "..", "univers_eneria_reseau_ftl.json")
    
    if not os.path.exists(ftl_file):
        st.error(f"‚ùå Fichier de donn√©es FTL non trouv√©: {ftl_file}")
        return None
    
    try:
        with open(ftl_file, 'r', encoding='utf-8') as f:
            return json.load(f)
    except Exception as e:
        st.error(f"‚ùå Erreur lors du chargement des donn√©es FTL: {e}")
        return None

def create_network_graph(data: Dict, show_private: bool = True, max_distance: int = None, node_size: int = 15) -> Tuple[List[Node], List[Edge]]:
    """
    Cr√©e les n≈ìuds et ar√™tes pour le graphique de r√©seau
    
    Args:
        data: Donn√©es FTL charg√©es depuis le JSON
        show_private: Si True, affiche les liens priv√©s
    
    Returns:
        Tuple contenant (nodes, edges)
    """
    nodes = []
    edges = []
    
    # Cr√©er les n≈ìuds (syst√®mes)
    systems = data.get('systems', {})
    for system_name, system_data in systems.items():
        # Taille du n≈ìud avec facteur de connexions mais contr√¥l√©e par le slider
        connections_count = system_data.get('connections_count', 0)
        size = node_size + (connections_count * 2)  # Taille de base + bonus pour connexions
        
        node = Node(
            id=system_name,
            label=system_name,
            size=size,
            color="#4A90E2",  # Bleu pour tous les syst√®mes
            font={"size": max(8, node_size // 2), "color": "#FFFFFF"},
            shape="dot"
        )
        nodes.append(node)
    
    # Cr√©er les ar√™tes (connexions)
    connections = data.get('connections', [])
    edge_id = 0
    
    for conn in connections:
        # V√©rifier si on doit afficher les liens priv√©s
        is_private = conn.get('prive', False) or conn.get('status', '').lower().find('priv√©e') >= 0
        if is_private and not show_private:
            continue
        
        # Filtrer par distance si sp√©cifi√©
        distance = conn.get('distance', 5)
        if max_distance and distance > max_distance:
            continue
        
        # Couleur selon le type de connexion
        if is_private:
            color = "#FF6B6B"  # Rouge pour les liens priv√©s
            width = 2
            dashes = True
        else:
            color = "#51CF66"  # Vert pour les liens r√©pertori√©s
            width = 3
            dashes = False
        
        # Largeur et longueur proportionnelles √† la distance
        distance = conn.get('distance', 5)
        width = max(1, 6 - distance)  # Largeur inversement proportionnelle
        length = distance * 20  # Longueur proportionnelle √† la distance
        
        edge = Edge(
            source=conn['source'],
            target=conn['target'],
            color=color,
            width=width,
            dashes=dashes,
            label=f"Distance: {distance}",
            font={"size": 10},
            length=length  # Contr√¥le la longueur visuelle de l'ar√™te
        )
        edges.append(edge)
        edge_id += 1
    
    return nodes, edges

def show_network_stats(data: Dict, show_private: bool = True, max_distance: int = None):
    """Affiche les statistiques du r√©seau"""
    if not data:
        return
    
    metadata = data.get('metadata', {})
    systems = data.get('systems', {})
    connections = data.get('connections', [])
    
    # Filtrer les connexions selon l'affichage et la distance
    if show_private:
        visible_connections = connections
    else:
        visible_connections = [c for c in connections if not (c.get('prive', False) or c.get('status', '').lower().find('priv√©e') >= 0)]
    
    # Filtrer par distance si sp√©cifi√©
    if max_distance:
        visible_connections = [c for c in visible_connections if c.get('distance', 5) <= max_distance]
    
    # Statistiques de base
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        st.metric("üåü Syst√®mes", len(systems))
    
    with col2:
        st.metric("üîó Connexions visibles", len(visible_connections))
    
    with col3:
        public_count = len([c for c in connections if not (c.get('prive', False) or c.get('status', '').lower().find('priv√©e') >= 0)])
        st.metric("üì° Liens r√©pertori√©s", public_count)
    
    with col4:
        private_count = len([c for c in connections if (c.get('prive', False) or c.get('status', '').lower().find('priv√©e') >= 0)])
        st.metric("üîí Liens priv√©s", private_count)
    
    # Statistiques avanc√©es
    if visible_connections:
        st.subheader("üìä Statistiques du r√©seau affich√©")
        
        col1, col2 = st.columns(2)
        
        with col1:
            # Syst√®mes les plus connect√©s
            st.write("**Hubs principaux:**")
            sorted_systems = sorted(systems.items(), key=lambda x: x[1].get('connections_count', 0), reverse=True)
            for i, (name, data) in enumerate(sorted_systems[:5]):
                st.write(f"{i+1}. **{name}** - {data.get('connections_count', 0)} connexions")
        
        with col2:
            # Distribution des distances
            distances = [c.get('distance', 0) for c in visible_connections]
            if distances:
                avg_distance = sum(distances) / len(distances)
                max_distance = max(distances)
                min_distance = min(distances)
                
                st.write("**Distances FTL:**")
                st.write(f"‚Ä¢ Moyenne: {avg_distance:.1f} UA")
                st.write(f"‚Ä¢ Maximum: {max_distance} UA")
                st.write(f"‚Ä¢ Minimum: {min_distance} UA")

def main():
    """Interface principale de la page r√©seau FTL"""
    st.title("üåå R√©seau FTL - Visualisation interactive")
    st.markdown("Exploration graphique des connexions de transport FTL entre les syst√®mes stellaires")
    
    # Charger les donn√©es
    data = load_ftl_data()
    if not data:
        st.stop()
    
    # Contr√¥les
    st.sidebar.title("‚öôÔ∏è Configuration")
    
    # Toggle pour les liens priv√©s
    show_private = st.sidebar.checkbox(
        "üîí Afficher les liens priv√©s", 
        value=True,
        help="Les liens priv√©s sont repr√©sent√©s en rouge et en pointill√©s"
    )
    
    # Contr√¥le de la taille des n≈ìuds
    node_size = st.sidebar.slider(
        "ÔøΩ Taille des syst√®mes",
        min_value=5,
        max_value=50,
        value=15,
        help="Ajuster la taille des n≈ìuds repr√©sentant les syst√®mes stellaires"
    )
    
    # Filtre par distance
    if data and data.get('connections'):
        distances = [c.get('distance', 5) for c in data['connections']]
        if distances:
            max_dist = max(distances)
            min_dist = min(distances)
            
            distance_filter = st.sidebar.slider(
                "üöÄ Distance maximale FTL",
                min_value=min_dist,
                max_value=max_dist,
                value=max_dist,
                help="Filtrer les connexions par distance maximale"
            )
    
    # Afficher les statistiques
    if 'distance_filter' in locals():
        show_network_stats(data, show_private, distance_filter)
    else:
        show_network_stats(data, show_private)
    
    st.markdown("---")
    
    # L√©gende
    col1, col2 = st.columns(2)
    with col1:
        st.markdown("**üé® L√©gende:**")
        st.markdown("üîµ **Syst√®mes stellaires** - Taille proportionnelle aux connexions")
        st.markdown("üìè **Longueur des liens** - Proportionnelle √† la distance FTL")
    with col2:
        st.markdown("üü¢ **Liens r√©pertori√©s** - Connexions publiques connues")
        if show_private:
            st.markdown("üî¥ **Liens priv√©s** - Connexions secr√®tes ou non officielles")
        st.markdown("üéØ **Largeur des liens** - Inversement proportionnelle √† la distance")
    
    # Affichage du graphique
    st.subheader("üó∫Ô∏è Carte du r√©seau FTL")
    
    # Graphique Agraph interactif
    if 'distance_filter' in locals():
        nodes, edges = create_network_graph(data, show_private, distance_filter, node_size)
    else:
        nodes, edges = create_network_graph(data, show_private, None, node_size)
    
    config = Config(
        width=1000,
        height=700,
        directed=False,
        physics=True,
        hierarchical=False,
        nodeHighlightBehavior=True,
        highlightColor="#F7A7A6",
        collapsible=False,
        # Configuration de physique pour respecter les distances
        physics_config={
            "enabled": True,
            "barnesHut": {
                "gravitationalConstant": -8000,
                "centralGravity": 0.3,
                "springLength": 95,
                "springConstant": 0.04,
                "damping": 0.09
            },
            "maxVelocity": 50,
            "minVelocity": 0.1,
            "solver": "barnesHut",
            "stabilization": {"iterations": 150}
        }
    )
    
    if nodes and edges:
        agraph(nodes=nodes, edges=edges, config=config)
    else:
        st.warning("‚ö†Ô∏è Aucune donn√©e √† afficher avec les param√®tres actuels")
    
    # Informations techniques
    with st.expander("‚ÑπÔ∏è Informations techniques"):
        st.markdown(f"""
        **Source des donn√©es:** `univers_eneria_reseau_ftl.json`
        
        **Moteur de rendu:** Streamlit-Agraph (interactif)
        
        **Couleurs:**
        - üîµ Syst√®mes: Bleu (#4A90E2)
        - üü¢ Liens r√©pertori√©s: Vert (#51CF66) 
        - üî¥ Liens priv√©s: Rouge (#FF6B6B)
        
        **Proportionnalit√©:**
        - **Taille des n≈ìuds:** Base r√©glable + bonus connexions (√ó2)
        - **Longueur des ar√™tes:** Distance FTL (√ó20 pour physique)
        - **Largeur des ar√™tes:** Inversement proportionnelle √† la distance (6-distance)
        
        **Physique:** BarnesHut avec springs ajust√©s pour respecter les distances FTL
        """)
        
        st.markdown("**Contr√¥les:**")
        st.markdown("- üñ±Ô∏è **Drag:** D√©placer les n≈ìuds")
        st.markdown("- üîç **Zoom:** Molette de la souris")
        st.markdown("- üìè **Taille:** Slider dans la barre lat√©rale")
        st.markdown("- üîí **Liens priv√©s:** Toggle dans la barre lat√©rale")
        
        if 'distance_filter' in locals():
            st.markdown(f"**Filtre actuel:** Distance FTL ‚â§ {distance_filter} UA")

if __name__ == "__main__":
    main()
